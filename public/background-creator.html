<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Creator</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./base.css">
    <link rel="stylesheet" type="text/css" href="./background-style.css">
</head>

<body>
    
    

    <section id="nav" class="hide">
        <div class="content main-nav">
            <h1 class="nav-title">Background Creator</h1>

            <p class="url-text" event-url></p>

            <div class="options">
                <!-- <button download-image class="button button-secondary">
                  <span>Download Image</span>
                </button> -->

                <div class="event-list-wrapper">
                  <p class="option-title">Your Events: </p>
                  <select class="input" events-list>
                    
                  </select>
                </div>

                <button analyze-new-event class="button button-glared">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"></path><path d="M20 3v4"></path><path d="M22 5h-4"></path><path d="M4 17v2"></path><path d="M5 18H3"></path></svg>
                  <span>Analyze New Event</span>
                </button>
            </div>
        </div>
    </section>

    <section id="url-screen">
        <div class="content">
            <button class="close button button-secondary" close-url-screen>X</button>
            <h2 class="title">
               Generate a background
            </h2>
            <p class="description text">
                Paste your event website URL and let AI create a background.
            </p>

            <div class="input-card">
                <form id="event-url-form">
                  <input class="input" type="text" id="event-url-input" placeholder="www.your-event-website.com">

                  <button analyze-url-btn class="button button-glared">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon"><path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z"></path><path d="M20 3v4"></path><path d="M22 5h-4"></path><path d="M4 17v2"></path><path d="M5 18H3"></path></svg>
                    <span>Analyze Event & Generate Background</span>
                  </button>
                </form>
            </div>
        </div>
    </section>
    

    <section id="fetching-screen">
        <!-- <img src="./back.png" class="back"> -->
        <div class="content">
            <div class="loading-card">
                <h2 class="title">
                   Event web is being analyzed...
                </h2>
                <div class="progress-bar">
                  <div class="progress-bar-inner"></div>
                </div>
            </div>

            
        </div>
    </section>
   


    <section id="background-screen">
            <div class="content">
                <div class="background-content">
                  
                </div>
            </div>
    </section>
    

      


</body>

</html>

<script>
    const BackgroundManager = {
        state: {
            currentEvent:{
              screenshot: null,
              background: null,
              backgroundRefined: null,
              backgroundAbstract: null,
              backgroundGrad: null,
              backgroundRendered: null,
              backgroundColor: null,
              backgroundGeo: null,
              colors: null,
              url: null,
              uid: '',
            },

            events:[],
        },

        elements: {}, 


        async init() {
            this.showScreen('url-screen');

            this.setElements();
            this.bindEvents();

            this.checkStorage();
        },

        setElements() {
            this.elements = {
                urlScreen: document.querySelector('#url-screen'),
                analyzeUrlForm: document.querySelector('#event-url-form'),
                urlInput: document.querySelector('#event-url-input'),
                analyzeUrlBtn: document.querySelector('[analyze-url-btn]'),
                
                analyzeNewBtn: document.querySelector('[analyze-new-event]'),

                closeUrlScreen: document.querySelector('[close-url-screen]'),


                fetchingScreen: document.querySelector('#fetching-screen'),

                
                backHolder: document.querySelector('#background-screen .background-content'),


                eventUrlEl: document.querySelector('[event-url]'),


                // downloadImgEl: document.querySelector('[download-image]'),


                eventsListEl: document.querySelector('[events-list]'),

            } 
        },

        bindEvents() {
            this.elements.analyzeUrlForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const url = this.elements.urlInput.value;
                if (url) {
                    this.fetchAllData(url);
                } else {
                    console.log('Please enter a valid URL.');
                }
            });
            

            // this.elements.downloadImgEl.addEventListener('click',(e)=>{
            //    this.downloadCurrentImage();
            // });


            this.elements.closeUrlScreen.addEventListener('click',()=>{
                this.elements.urlScreen.classList.remove('modal');
            });
            this.elements.analyzeNewBtn.addEventListener('click',()=>{
                 this.analyzeNewEvent();
            });


            this.elements.eventsListEl.addEventListener('change',()=>{
                  this.selectEvent();
            });
        },


        async fetchApi(endpoint, options = {}) {
            try {
                options.credentials = 'include'; 

                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({
                        error: 'An unknown server error occurred.'
                    }));
                    throw new Error(errorData.error || `Server responded with status: ${response.status}`);
                }
                return response.json();
            } catch (error) {
                console.error(`Failed to fetch ${endpoint}:`, error);
                throw error;
            }
        },
        async fetchBinaryApi(endpoint, options = {}) {
           try {
               options.credentials = 'include'; 

               const response = await fetch(endpoint, options);
               
               if (!response.ok) {
                   const errorData = await response.json().catch(() => ({
                       error: 'Server responded with a non-JSON error format.'
                   }));
                   
                   throw new Error(errorData.error || `Server responded with status: ${response.status}`);
               }
               return response;

           } catch (error) {
               console.error(`Failed to fetch ${endpoint} (Binary Call):`, error);
               throw error;
           }
        },


        async fetchAllData(url) {
            this.showScreen('fetching-screen');
            
            console.log(`Fetching data for: ${url}`);

            

            this.setLoadingProgress(2);


            let uid = this.generateUniqueCode();
                
            

            this.state.currentEvent= {
              screenshot: null,
              background: null,
              backgroundRefined: null,
              backgroundAbstract: null,
              backgroundGrad: null,
              backgroundRendered: null,
              backgroundColor: null,
              backgroundGeo: null,
              colors: null,
              url: null,
              uid: '',
            };

            this.state.currentEvent.uid = uid;

            this.state.currentEvent.url = url;

            this.state.events.push({
                uid: uid,
                eventData: this.state.currentEvent,
            });

            this.renderBackground();
        
            try {
                
                await this.getWebData();
                this.setLoadingProgress(3);

                await this.saveScreenshot();
                
                this.setLoadingProgress(5);

                

                // Transition the UI to the results screen
                const screen = document.querySelector('#fetching-screen');
                screen.classList.add('end-loading');

                this.setLoadingProgress(7);

                await new Promise(r => setTimeout(r, 500));

                this.showScreen('background-screen');
                this.renderEvents();

                
                await this.getPrimaryColorsFromImage();

                
                await this.initBackgroundCanvas();
                this.renderBackground();


                await this.getBackgroundImage();
                this.renderBackground();


                await this.initFilteredBackground();
                this.renderBackground();


                await this.getRefinedBackgroundImage();
                this.renderBackground();


                
                this.saveData('full_background_data', this.state);

        
            } catch (error) {
                // --- Failure Path ---
                console.error("Data fetch failed:", error.message);
            }
        },
        

        async getWebData(){
            const response = await this.fetchApi('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: this.state.currentEvent.url, 
                                       request: 'web_data',
                                       webData: null })
            });
        
            console.log("Web Data received", response);
        
            this.state.currentEvent.screenshot = response.screenshot;
        },
        async saveScreenshot(){
            let imageUrl = this.state.currentEvent.screenshot;
            let imageSaved = await this.saveImageByUrl(imageUrl);


            this.state.currentEvent.screenshot = imageSaved.url;

            console.log("screenshot saved");
        },


       

        analyzeNewEvent(){
            // this.showScreen('url-screen');
            this.elements.urlScreen.classList.add('modal');

            const screen = document.querySelector('#fetching-screen');
            screen.classList.remove('end-loading');
        },

        
        async getBackgroundImage(){
            let postData = {
                
                imageUrl: this.state.currentEvent.screenshot, 
            }

            console.log(postData);

            const response = await this.fetchApi('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: this.state.currentEvent.url, 
                                       request: 'background_image', 
                                       webData: JSON.stringify(postData) })
            });
        
        

            let imageSaved = await this.saveImageByData(response.backgroundImage, this.getUUID());

            console.log("Image Received and Saved:", imageSaved);

            // Update state with the new data
            this.state.currentEvent.background = imageSaved.url;       
        },
        async getRefinedBackgroundImage(){
            let postData = {
                
                imageUrl: this.state.currentEvent.background, 
            }

            console.log(postData);

            const response = await this.fetchApi('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: this.state.currentEvent.url, 
                                       request: 'refine_background_image', 
                                       webData: JSON.stringify(postData) })
            });
        
        

            let imageSaved = await this.saveImageByData(response.backgroundImage, this.getUUID());

            console.log("Image Received and Saved:", imageSaved);

            // Update state with the new data
            this.state.currentEvent.backgroundRefined = imageSaved.url;       
        },

 
        async getPrimaryColorsFromImage() {
          let postData = {
              
              imageUrl: this.state.currentEvent.screenshot, 
          }

          console.log(postData);

          const response = await this.fetchApi('/api/analyze', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url: this.state.currentEvent.url, 
                                     request: 'primary_colors', 
                                     webData: JSON.stringify(postData) })
          });
        
        
          console.log("data colors: ", response);

          // Update state with the new data
          this.state.currentEvent.colors = response.colors; 
        },


        createAbstractBackground(colorData, width = 1344, height = 768) {
          if (!colorData || colorData.length < 1) {
              throw new Error("Color data array cannot be empty.");
          }

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = width;
          canvas.height = height;
          
          // --- Preprocessing: Create weighted list for proportional color selection ---
          const weightedColors = [];
          let totalPercentage = 0;
          colorData.forEach(data => totalPercentage += data.percentage);

          colorData.forEach(data => {
              // Create an entry in the weighted list proportional to the percentage
              // We use Math.floor to ensure an integer count, scaled by 100 for granularity
              const weight = Math.floor(data.percentage / totalPercentage * 100);
              for (let i = 0; i < weight; i++) {
                  weightedColors.push(data.hex);
              }
          });

          // --- 1. Initial Setup (Base Color) ---
          // Use the most dominant color (colorData[0]) as the base background.
          ctx.fillStyle = colorData[0].hex;
          ctx.fillRect(0, 0, width, height);

          // --- 2. Pattern Generation Settings (Crucial for subtlety) ---
          const patternElementCount = 18; // Number of overlapping elements
          
          // Low opacity (0.1 to 0.3) is KEY for allowing text readability
          ctx.globalAlpha = 0.25; 
          
          // Apply a medium-heavy blur to make shapes indistinct and flowing
          const blurStrength = Math.floor(width / 30);
          ctx.filter = `blur(${blurStrength}px)`; 

          // --- 3. Draw Subtly Colored, Soft Shapes ---
          for (let i = 0; i < patternElementCount; i++) {
              // Select color from the weighted list (dominant colors selected more often)
              const hexColor = weightedColors[Math.floor(Math.random() * weightedColors.length)];
              
              ctx.fillStyle = hexColor; 

              // Generate large, smooth shapes that blend into one another
              const minRadius = width * 0.2;
              const maxRadius = width * 0.4;
              const radius = Math.random() * (maxRadius - minRadius) + minRadius;

              // Position shapes slightly off-canvas to ensure soft edges at the border
              const x = Math.random() * width * 1.5 - width * 0.25; 
              const y = Math.random() * height * 1.5 - height * 0.25;

              // Draw the blob
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, 2 * Math.PI);
              ctx.fill();
          }
          
          // --- 4. Final Polish and Cleanup ---
          ctx.globalAlpha = 1.0; 
          ctx.filter = 'none'; // Reset filter before final output

          // 5. Return the resulting image as a data URL
          return canvas.toDataURL('image/webp', 0.8);
        },
        createGradientBackground(colorData, width = 1344, height = 768) {
            if (!colorData || colorData.length < 2) {
                throw new Error("Color data must contain at least two entries for a gradient.");
            }
            
            // 1. Setup Canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;
        
            // 2. Create the Gradient Object (Diagonal: top-left (0,0) to bottom-right (width,         height))
            const gradient = ctx.createLinearGradient(0, 0, width, height);
        
            // 3. Define Color Stops based on Cumulative Percentage
            let cumulativePercentage = 0;
            
            colorData.forEach((data, index) => {
                // Calculate the position (0.0 to 1.0) for the color stop.
                // The first color starts at 0, the subsequent colors start where the previous         one ended.
                const startStop = cumulativePercentage / 100;
                
                // Add the current color's percentage to the cumulative total
                cumulativePercentage += data.percentage;
        
                // Add the color stop at the calculated position
                gradient.addColorStop(startStop, data.hex);
                
                // For the *last* color, ensure it reaches the 100% mark
                if (index === colorData.length - 1) {
                     gradient.addColorStop(1.0, data.hex);
                }
            });
        
            // 4. Apply the Gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // 5. Apply a subtle blur filter for extra smoothness (Optional)
            ctx.filter = `blur(1px)`; 
            ctx.drawImage(canvas, 0, 0);
        
            // 6. Return the resulting image as a data URL
            return canvas.toDataURL('image/webp', 0.9);
        },
        createFullColorBackground(colorData, width = 1344, height = 768) {
          if (!colorData || colorData.length === 0) {
              throw new Error("Color data array cannot be empty.");
          }

          // 1. Extract the dominant color (from the first element)
          const dominantColor = colorData[0].hex;

          // 2. Setup Canvas
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = width;
          canvas.height = height;

          // 3. Fill the entire canvas with the dominant color
          ctx.fillStyle = dominantColor;
          ctx.fillRect(0, 0, width, height);
          
          // 4. Return the resulting image as a data URL
          // We use a high quality for a clean, solid color image
          return canvas.toDataURL('image/webp', 1.0); 
        },
        createGeometricGradientBackground(colorData, width = 1344, height = 768){
          if (!colorData || colorData.length < 1) {
              throw new Error("Color data array cannot be empty.");
          }

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = width;
          canvas.height = height;
          
          // --- Preprocessing: Create weighted list for proportional color selection ---
          const weightedColors = [];
          let totalPercentage = 0;
          colorData.forEach(data => totalPercentage += data.percentage);

          colorData.forEach(data => {
              const weight = Math.floor(data.percentage / totalPercentage * 100);
              for (let i = 0; i < weight; i++) {
                  weightedColors.push(data.hex);
              }
          });

          // --- 1. Initial Setup (Base Color) ---
          ctx.fillStyle = colorData[0].hex; // Use the most dominant color as the base
          ctx.fillRect(0, 0, width, height);

          // --- 2. Pattern Generation Settings ---
          const elementCount = 25; // Number of overlapping polygons
          
          ctx.globalAlpha = 0.18; 
          ctx.filter = `blur(${Math.floor(width / 300)}px)`; 

          // --- Helper function to draw a polygon ---
          function drawPolygon(context, x, y, radius, sides, rotation = 0) {
              context.beginPath();
              for (let i = 0; i < sides; i++) {
                  const angle = rotation + (i * 2 * Math.PI) / sides;
                  const px = x + radius * Math.cos(angle);
                  const py = y + radius * Math.sin(angle);
                  if (i === 0) {
                      context.moveTo(px, py);
                  } else {
                      context.lineTo(px, py);
                  }
              }
              context.closePath();
              context.fill();
          }

          // --- 3. Draw Geometric Shapes (Rotated Polygons with Gradients) ---
          for (let i = 0; i < elementCount; i++) {
              const color1 = weightedColors[Math.floor(Math.random() * weightedColors.length)];
              const color2 = weightedColors[Math.floor(Math.random() * weightedColors.length)];

              // Create a linear gradient for each shape, spanning broadly
              const gradient = ctx.createLinearGradient(0, 0, width, height); 
              gradient.addColorStop(0, color1);
              gradient.addColorStop(1, color2);
              ctx.fillStyle = gradient;

              // Random center position
              const centerX = Math.random() * width * 1.2 - width * 0.1;
              const centerY = Math.random() * height * 1.2 - height * 0.1;

              // Random radius for the polygon
              const minPolygonRadius = width * 0.1;
              const maxPolygonRadius = width * 0.35;
              const polygonRadius = Math.random() * (maxPolygonRadius - minPolygonRadius) + minPolygonRadius;

              // Random number of sides (from 3 for triangle to 8 for octagon)
              const sides = Math.floor(Math.random() * 6) + 3; // 3 to 8 sides

              // Random rotation
              const rotation = Math.random() * Math.PI * 2; // Full 360-degree rotation

              // Draw the polygon using the helper function
              drawPolygon(ctx, centerX, centerY, polygonRadius, sides, rotation);
          }
          
          // --- 4. Final Polish and Cleanup ---
          ctx.globalAlpha = 1.0; 
          ctx.filter = 'none';

          // 5. Return the resulting image as a data URL
          return canvas.toDataURL('image/webp', 0.8);
        },
        async initBackgroundCanvas(){
           let image = this.state.currentEvent.screenshot;

           let colorsData = this.state.currentEvent.colors;


           try{
              const response = await this.fetchBinaryApi('/api/analyze', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ url: image, 
                                         request: 'download_image', 
                                         webData: image })
              });

              const imageBlob = await response.blob();


              let newDataAbs = await this.createAbstractBackground(colorsData);
              let savedAbs = await this.saveImageByUrl(newDataAbs,'backgroundAbs');


              let newDataColor = await this.createFullColorBackground(colorsData);
              let savedColor = await this.saveImageByUrl(newDataColor,'backgroundColor');


              let newDataGeo = await this.createGeometricGradientBackground(colorsData);
              let savedGeo = await this.saveImageByUrl(newDataGeo,'backgroundGeo');


              let newDataGrad = await this.createGradientBackground(colorsData);
              let savedGrad = await this.saveImageByUrl(newDataGrad,'backgroundGrad');


              this.state.currentEvent.colors = colorsData;
              this.state.currentEvent.backgroundAbstract = savedAbs.url;
              this.state.currentEvent.backgroundGrad = savedGrad.url;
              this.state.currentEvent.backgroundColor = savedColor.url;
              this.state.currentEvent.backgroundGeo = savedGeo.url;
           }
           catch(error){
              console.error(error);
           }
        },


        



        applyAggressiveFilter(imageBlob, width = 1344, height = 768) {
           return new Promise((resolve, reject) => {
               // 1. Create temporary Blob URL
               const blobUrl = URL.createObjectURL(imageBlob);

               const img = new Image();
               // Since we are using a blob URL, crossOrigin is typically not needed 
               // and should be omitted or set to 'anonymous' if necessary for some environments.
               
               img.onload = function() {
                   // CRITICAL: Cleanup the temporary Blob URL immediately after the image data is loaded
                   URL.revokeObjectURL(blobUrl);

                   const canvas = document.createElement('canvas');
                   const ctx = canvas.getContext('2d');
                   canvas.width = width;
                   canvas.height = height;

                   // 1. Apply Aggressive Blur Filter
                   ctx.filter = `blur(40px)`;
                   ctx.drawImage(this, 0, 0);

                   // 2. Achieve "Smear" Effect (Repetitive Offset Drawing)
                   ctx.globalAlpha = 0.5; // Make the smears semi-transparent

                   for (let i = 0; i < 5; i++) {
                       const offset = i * 5;
                       
                       // Draw blurred image again, slightly offset
                       ctx.drawImage(canvas, 0, 0, this.width, this.height, 
                                     offset, offset, this.width - offset, this.height - offset);
                   }

                   // Reset context properties
                   ctx.globalAlpha = 1.0;
                   ctx.filter = 'none';

                   // 3. Save the Image Data
                   const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                   resolve(dataURL);
               };

               img.onerror = (e) => {
                   // CRITICAL: Cleanup on error too!
                   URL.revokeObjectURL(blobUrl);
                   reject(new Error("Failed to load image from Blob URL: " + e.message));
               };
               
               // Assign the Blob URL to the image source
               img.src = blobUrl;
           });
        },
        async initFilteredBackground(){
          let image = this.state.currentEvent.background;
           
          try{
             const response = await this.fetchBinaryApi('/api/analyze', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ url: image, 
                                         request: 'download_image', 
                                         webData: image })
              });

             const imageBlob = await response.blob();

             let imageData = await this.applyAggressiveFilter(imageBlob);


 
             let saved = await this.saveImageByUrl(imageData,'backgroundFiltered');

             this.state.currentEvent.backgroundFiltered = saved.url;
          }
          catch(error){
            console.error(error);
          }
        },



        
        async downloadCurrentImage() {
             // --- 1. Retrieve Data and URL ---
             let imageIndex = this.state.currentEvent.currentPost.selectedImage;
             let image = this.state.currentEvent.currentPost.images[imageIndex];
             let date = this.state.currentEvent.currentPost.date;
             let name = this.state.currentEvent.eventData.eventName;
         
             // --- 2. Sanitize and Format Filename ---
             let combinedName = `${name} ${date}`;
             let sanitizedBaseName = combinedName.trim().toLowerCase();
             sanitizedBaseName = sanitizedBaseName.replace(/[<>:"/\\|?*]|^\.+|\.+$/g, '-');
             sanitizedBaseName = sanitizedBaseName.replace(/\s+/g, '-');
             sanitizedBaseName = sanitizedBaseName.replace(/-+/g, '-');
             sanitizedBaseName = sanitizedBaseName.replace(/^-|-$/g, '');
         
             // Get the final extension from the image URL to create a complete filename
             const urlParts = image.split('.');
             const extension = urlParts.pop().split('?')[0] || 'jpg';
             const finalFileName = `${sanitizedBaseName}.${extension}`;
         
             // --- 3. Initiate Server-Side Proxy Download ---
             try {

                 const response = await this.fetchBinaryApi('/api/analyze', {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ url: this.state.currentEvent.url, 
                                            request: 'download_image', 
                                            webData: image })
                 });

                 console.log(response);
                 
                 const imageBlob = await response.blob();
                 
                 
                 const blobUrl = URL.createObjectURL(imageBlob);
                 const link = document.createElement('a');
                 
                 link.href = blobUrl;
                 link.download = finalFileName;
                 
                 document.body.appendChild(link);
                 link.click();
                 
                 document.body.removeChild(link);
                 URL.revokeObjectURL(blobUrl);


                 console.log(`Proxy download request sent for ${finalFileName}.`);
         
             } catch (error) {
                 console.error("Client-side download initiation failed:", error);
             }
        },

        

        async saveImageByUrl(imageUrl){

            let newImageData = null;
            try {
              let imageBlob = await this.urlStringToBlob(imageUrl);

              newImageData = await this.encodeLocalImage(imageBlob);
            } catch (error) {
              console.error("Image processing error:", error);
              return;
            }

            newImageData['name'] = this.getImageName(imageUrl);

            console.log(newImageData);

            const response = await this.fetchApi('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: this.state.currentEvent.url, 
                                       request: 'save_image', 
                                       webData: JSON.stringify(newImageData) })
            });

            return response;
        },
        async saveImageByData(imageData,name){

            imageData['name'] = name;

            console.log(imageData);

            const response = await this.fetchApi('/api/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: this.state.currentEvent.url, 
                                       request: 'save_image', 
                                       webData: JSON.stringify(imageData) })
            });

            return response;
        },

        async downloadImageFromUrl(url, fileName) {
          try {
              const response = await fetch(url);
              
              if (!response.ok) {
                  throw new Error(`Failed to fetch image: Status ${response.status}`);
              }

              // 1. Get the image data as a Blob
              const imageBlob = await response.blob();
              
              // 2. Create a temporary URL for the Blob
              const blobUrl = URL.createObjectURL(imageBlob);

              // 3. Create a temporary anchor element and click it
              const link = document.createElement('a');
              link.href = blobUrl;
              link.download = fileName;
              
              // Trigger the download
              document.body.appendChild(link);
              link.click();
              
              // Clean up the temporary elements and object URL
              document.body.removeChild(link);
              URL.revokeObjectURL(blobUrl);

              console.log(`Download initiated for ${fileName}.`);

          } catch (error) {
              console.error("Download failed:", error);
          }
        },







        selectEvent(){
          let eventUID = this.elements.eventsListEl.value;
          let selectedEvent = this.state.events.filter(event => event.uid === eventUID); 
          console.log(eventUID);
          console.log(selectedEvent[0].eventData);

          this.state.currentEvent = selectedEvent[0].eventData;

          this.renderBackground();
          this.renderEvents()
        },
        renderEvents(){
            let events = '';
            this.state.events.forEach(event=>{
                 events += `
                    <option class="event-item" 
                       value="${event.uid}" 
                       ${(this.state.currentEvent.uid == event.uid)? ' selected' : ''} >
                         ${event.eventData.url}
                    </option>
                 `;
            });
            this.elements.eventsListEl.innerHTML = events;
        },

        
        // --- UI RENDERING ---
        showScreen(screenName) { 
            let screens = document.querySelectorAll('section');
            screens.forEach(screen=>{
              screen.classList.add('hide');
            });

            let screen = document.querySelector(`#${screenName}`);
            screen.classList.remove('hide');
            if(this.elements.urlScreen){
                this.elements.urlScreen.classList.remove('modal');
            }

            if(screenName == 'fetching-screen'){
                screen.classList.add('loading');
            }
            if(screenName == 'background-screen'){
                 document.querySelector('#nav').classList.remove('hide');
            }
        },
        

        
        setLoadingProgress(val){
           this.elements.fetchingScreen.setAttribute('progress',val);
        },


        renderBackground(){
            let screenshotUrl = this.state.currentEvent.screenshot;
            let imageUrl = this.state.currentEvent.background;
            let imageRefinedUrl = this.state.currentEvent.backgroundRefined;
            let imageColorUrl = this.state.currentEvent.backgroundColor;
            let imageAbsUrl = this.state.currentEvent.backgroundAbstract;
            let imageGradUrl = this.state.currentEvent.backgroundGrad;
            let imageFilteredUrl = this.state.currentEvent.backgroundFiltered;
            let imageGeoUrl = this.state.currentEvent.backgroundGeo;

            let colors = this.state.currentEvent.colors;

            let colorsHtml = `<div class="colors-holder">
                             <h2>Colors Found</h2>
                          </div>`;

            let screenshotImg = `<div class="img-holder">
                              <h2>Screenshot Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;
            let backImg = `<div class="img-holder">
                              <h2>AI Background Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;
            let backRefinedImg = `<div class="img-holder">
                              <h2>AI Refined Background Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;
            let backColorImg = `<div class="img-holder">
                              <h2>Full Color Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;
            let backGradImg = `<div class="img-holder">
                              <h2>Blur Gradient Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;
            // let backAbsImg = `<div class="img-holder">
            //                   <h2>Abstract Image</h2>
            //                   <div class="loader"></div>
            //                </div>
            //               `;              
            let backFilteredImg = `<div class="img-holder">
                              <h2>Filtered Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;
            let backGeoImg = `<div class="img-holder">
                              <h2>Geometric Image</h2>
                              <div class="loader"></div>
                           </div>
                          `;


            // if(imageUrl != null){
            //    backImg = `<div class="img-holder">
            //                   <h2>AI Background Image</h2>
            //                   <img class="background-image" width="100%" height="100%"
            //                   src="${imageUrl}" >
            //               </div>`;
            // }
            if(colors != null && colors.length > 0){
              colorsHtml = `<div class="colors-holder">
                             <h2>Colors Found</h2>
                             <h3 class="color-holder">
                               <span style="background-color:${colors[0].hex}"></span>
                               ${colors[0].hex} : ${colors[0].percentage}%
                             </h3>
                             <h3 class="color-holder">
                               <span style="background-color:${colors[1].hex}"></span>
                               ${colors[1].hex} : ${colors[1].percentage}%
                             </h3>
                          </div>`;
            }
            if(screenshotUrl != null){
               screenshotImg = `<div class="img-holder">
                              <h2>Screenshot Background Image</h2>
                              <img class="background-image" width="100%" height="100%"
                              src="${screenshotUrl}" >
                          </div>`;
            }
            if(imageRefinedUrl != null){
               backRefinedImg = `<div class="img-holder">
                              <h2>AI Refined Background Image</h2>
                              <img class="background-image" width="100%" height="100%"
                              src="${imageRefinedUrl}" >
                          </div>`;
            }
            if(imageColorUrl != null){
               backColorImg = `<div class="img-holder">
                              <h2>Full Color Image</h2>
                              <img class="background-image" width="100%" height="100%"
                              src="${imageColorUrl}" >
                          </div>`;
            }
            // if(imageAbsUrl != null){
            //    backAbsImg = `<div class="img-holder">
            //                   <h2>Abstract Image</h2>
            //                   <img class="background-image" width="100%" height="100%"
            //                   src="${imageAbsUrl}" >
            //               </div>`;
            // }
            if(imageGradUrl != null){
               backGradImg = `<div class="img-holder">
                              <h2>Blur Gradient Image</h2>
                              <img class="background-image" width="100%" height="100%"
                              src="${imageGradUrl}" >
                          </div>`;
            }
            if(imageFilteredUrl != null){
               backFilteredImg = `<div class="img-holder">
                              <h2>Filtered Image</h2>
                              <img class="background-image" width="100%" height="100%"
                              src="${imageFilteredUrl}" >
                          </div>`;
            }
            if(imageGeoUrl != null){
               backGeoImg = `<div class="img-holder">
                              <h2>Geometric Image</h2>
                              <img class="background-image" width="100%" height="100%"
                              src="${imageGeoUrl}" >
                          </div>`;
            }

            this.elements.backHolder.innerHTML = `
               ${colorsHtml}
               ${screenshotImg}
               ${backRefinedImg}
               ${backColorImg}
               ${backGradImg}
               ${backGeoImg}
               ${backFilteredImg}
            `;
        },



        // saving and loading
        checkStorage(){
           let data = this.loadData('full_background_data');
           if(data == null){
             return;
           }
           
           this.state = data;

           if(!this.state.currentEvent.uid){
             this.state.currentEvent = this.state.events[0].eventData;
           }

           this.showScreen("background-screen");
           this.renderBackground();
           this.renderEvents();
        },
        saveData(key, data) {
            try {
                // Convert the JavaScript object into a JSON string before saving.
                const serializedData = JSON.stringify(data);
                localStorage.setItem(key, serializedData);
                console.log(`Data saved successfully for key: ${key}`);
            } catch (error) {
                console.error("Error saving data to localStorage:", error);
            }
        },
        loadData(key) {
            try {
                const serializedData = localStorage.getItem(key);
                
                // Return null if no data is found for the key.
                if (serializedData === null) {
                    console.log(`No data found for key: ${key}`);
                    return null;
                }
                
                // Convert the JSON string back into a JavaScript object.
                return JSON.parse(serializedData);
            } catch (error) {
                console.error("Error retrieving or parsing data from localStorage:", error);
                return null;
            }
        },



        // misc
        generateUniqueCode() {
          // 1. Get the current Unix timestamp in milliseconds.
          const timestamp = Date.now();
          
          // 2. Convert the timestamp to a Base36 string (shorter, alphanumeric representation).
          const timeBase36 = timestamp.toString(36);
          
          // 3. Generate a small random component (using a character from a random Base36 string)
          // to ensure uniqueness when the function is executed in rapid succession.
          const randomComponent = Math.random().toString(36).substring(2, 3);
          
          // Combine time and a small random factor.
          return timeBase36 + randomComponent;
        },

        async encodeLocalImage(fileObject) {
            return new Promise((resolve, reject) => {
                
                if (!fileObject) {
                    return reject(new Error("No file object provided."));
                }
                
                if (!(fileObject instanceof Blob)) { 
                     return reject(new TypeError("Invalid input: Expected a File or Blob object."));
                }
        
                const mimeType = fileObject.type;
                const reader = new FileReader();
        
                reader.onload = () => {
                    const dataUrl = reader.result;
        
                    const base64Index = dataUrl.indexOf(',');
                    if (base64Index === -1) {
                        return reject(new Error("Could not parse file data URL."));
                    }
                    
                    const base64Data = dataUrl.substring(base64Index + 1);
        
                    resolve({
                        data: base64Data,
                        mimeType: mimeType
                    });
                };
        
                reader.onerror = (error) => {
                    reject(new Error(`Error reading file: ${error.target.error.name}`));
                };
        
                reader.readAsDataURL(fileObject);
            });
        },
        async urlStringToBlob(imageUrl) {
            if (!imageUrl || typeof imageUrl !== 'string') {
                throw new Error('Invalid URL string provided.');
            }
        
            try {
                console.log(`Fetching image from URL: ${imageUrl}`);
                
                // 1. Fetch the resource as a response stream
                const response = await fetch(imageUrl);
        
                if (!response.ok) {
                    throw new Error(`Failed to fetch image: Status ${response.status}`);
                }
        
               
                const imageBlob = await response.blob();
                
                return imageBlob;
        
            } catch (error) {
                console.error('Error converting URL to Blob:', error);
                throw new Error(`Could not process image URL: ${error.message}`);
            }
        },

        dataToUrl(imageData) {

            if(imageData?.data == null || imageData?.mymeType == null){
                return null;
            }

            const dataUrl = `data:${imageData?.mymeType};base64,${imageData?.data}`;
            
            return dataUrl;
        },

        getImageName(imageUrl) {
            if (!imageUrl || typeof imageUrl !== 'string') {
                return '';
            }
        
            const parts = imageUrl.split('/');
            let fileNameWithExtensionAndQuery = parts.pop() || '';

            if (fileNameWithExtensionAndQuery === '') {
                fileNameWithExtensionAndQuery = parts.pop() || '';
            }
        
            const fileWithExtension = fileNameWithExtensionAndQuery.split('?')[0];
        
            const lastDotIndex = fileWithExtension.lastIndexOf('.');
        
            if (lastDotIndex !== -1) {
                return fileWithExtension.substring(0, lastDotIndex);
            }
            
            return fileWithExtension;
        },

        getUUID() {
            const timeNow = Date.now();
            const randomPart1 = Math.floor(Math.random() * 0xFFFFFFFFFF).toString(16).padStart(10, '0');
            const randomPart2 = Math.floor(Math.random() * 0xFFFFFFFFFF).toString(16).padStart(10, '0');
            
            const timeHex = timeNow.toString(16).padStart(12, '0');
            const uuid = 
                timeHex.substring(0, 8) + '-' + 
                timeHex.substring(8, 12) + '-' + 
                '4' + randomPart1.substring(0, 3) + '-' + 
                'a' + randomPart1.substring(3, 6); 
            
            return uuid;
        },

    };

    document.addEventListener('DOMContentLoaded', () => {
        BackgroundManager.init();
    });
</script>



